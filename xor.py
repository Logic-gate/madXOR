#!/usr/bin/env python

__author__ = ["A'mmer Almadani:Mad_Dev", "penbang.sysbase.org"]
__email__  = ["mad_dev@linuxmail.org", "mail@sysbase.org"]

from itertools import izip, cycle
import random
import string
import urllib2
import math
import tarfile


class Xor():
   def xorOperation(self, message, key):
      '''XOR Operation: message (+) key = key (+) secret
         Two Arguments: 1- message to decrypt|encrypt
                        2- key
         Notes on Key:  Key is random; generated by rand()
         '''
      return ''.join(chr(ord(x) ^ ord(y)) for (x,y) in izip(message, cycle(key)))

   def rand(self, size=[], chars=string.ascii_letters + string.digits + string.hexdigits + string.punctuation + string.whitespace):
      '''Generate a random key based on the message length
      TODO: Provide string option'''
      return ''.join(random.choice(chars) for x in range(size))

   def read(self, data):
      '''Simple read function'''
      x = open(data, 'rb')
      #is it safe not to close????
      return x.read()

   def getFile(self, doc):
      '''File to encrypt
         Envoke read()'''
      return self.read(doc)

   def getKey(self, doc, getHtml, key_out):
      '''Envoke getFile()

         We calculate the length of the file and
         generate a random key based on it.

         Envoke save()'''
      getFile = self.getFile(doc)
      n = len(getFile)
      for i in getFile:
            key = self.rand(n) #rand(size)
      self.save(key_out, key)
      return key

   def save(self, path, doc):
      '''Simple save function'''
      s = open(path, 'w')
      s.write(doc)
      s.close
   def add(self, path, doc):
      '''Simple append function'''
      s = open(path, 'a')
      s.write(doc)
      s.close

   def encrypt(self, doc, output, key_out, entropy):
      '''Envoke getFile()
         Envoke getKey()
         Envoke xorOperation()
         Envoke save()
         encrypt(file_to_encrypt, name_of_output, name_of_key_output, entorpy)
         Shannon Entropy Escape is entropy - 0.1.
         '''
      getFile = self.getFile(doc)
      getKey = self.getKey(doc, getFile, key_out)
      #print self.getEntropy(key_out)
      if self.getEntropy(key_out) > entropy:
         xor_in = self.xorOperation(getFile, getKey)
         self.save(output, xor_in)
      else:
         return self.encryptLoop(doc, output, key_out, entropy)

   def encryptLoop(self, doc, output, key_out, entropy):
      '''Subtract from entropy
         return encrypt()
         loop'''
      entropy = entropy - 0.1
      #print entropy
      return self.encrypt(doc, output, key_out, entropy)  

   def openSite(self, site):
      '''Requires urllib2
         if http in doc --> assume webpage.
         anything else, envoke read()'''
      if 'http://' in site:
         request = urllib2.Request(site)
         response = urllib2.urlopen(request)
         return response.read()
      else:
         return self.read(site)

   def readKey(self, key):
      '''readKey() differs from getKey() in that it reads a key to use for decrypting.
         if http in key --> envoke openSite()
         if . in key --> envoke read()
         anything else, assume string'''
      if 'http://' in key: 
            key = self.openSite(key)
            return key
      elif '.' in key:
            key = self.read(key)
            return key
      else:
            return str(key)

   def decrypt(self, doc, key, decrypted_file):
      '''Envoke openSite()
         Envoke readKey()
         Envoke xorOperation()
         Envoke save()

         decrypt(encrypted_file, key, name_of_decrypted_output) 
      '''
      getFile = self.openSite(doc)
      readKey = self.readKey(key)
      xor_out = self.xorOperation(getFile, readKey)
      self.save(decrypted_file, xor_out)

   def rubbish(self, encryptedDoc, output, n):
      '''generate a random footer 1/n of the size
         Becasue rubbish is added after the XOR operation, it could still be decrypted without
         removing it.

         Future versions will 'HOPEFULY' include a rubbish remover.
      '''
      getFile = self.getFile(encryptedDoc)
      getSize = self.getSize(encryptedDoc)[0]
      #generate Rubbish based on 1/n the the file size
      for i in getFile:
         rubbish = self.rand(getSize / n)
      self.save(output, rubbish)
      readRubbish = self.getFile(output)
      self.add(encryptedDoc, readRubbish)

   def getSize(self, entry):
      '''Return the size of entry [0]
         Return Array [1] '''
      size = open(entry, "rb")
      byte = map(ord, size.read())
      size.close()
      return len(byte), byte

   def getEntropy(self, entry):
      '''Get Shannon Entropy'''
      #Thanks to EvilSocket
      #http://www.emoticode.net/python/compute-the-shannon-entropy-of-a-file.html 
      getSize = self.getSize(entry)[0]
      byteArray = self.getSize(entry)[1]
      freqList = []
      for b in range(256):
          ctr = 0
          for byte in byteArray:
              if byte == b:
                  ctr += 1
          freqList.append(float(ctr) / getSize)
      ent = 0.0
      for freq in freqList:
          if freq > 0:
              ent = ent + freq * math.log(freq, 2)
      ent = -ent
      return ent

   def divide(self, encryptedDoc, chunkSize, division_name, entropy):
      '''Divide the encrypted file into chunkSize files
         division_name: the name of the chunks (string)

         Future versions will include encrypting the divided files
         '''
   #Thanks to Bidur Devkota
   #http://bdurblg.blogspot.com/2011/06/python-split-any-file-binary-to.html
   #Based on http://penbang.sysbase.org/other_projects/simple_xor.pdf slide 8
      f = open(encryptedDoc, 'rb')
      data = f.read()
      f.close()
      bytes = len(data)
      noOfChunks= bytes/chunkSize
      if(bytes%chunkSize):
         noOfChunks+=1
      f = open('info.txt', 'w')
      f.write(encryptedDoc+','+division_name+','+str(noOfChunks)+','+str(chunkSize))
      f.close()
      chunkNames = []
      for i in range(0, bytes+1, chunkSize):
         fn1 = "%s%s" %(division_name, i)
         #chunkKey = "key%s" %i
         #encryptedChunk = 'Encrypted%s' %i
         chunkNames.append(fn1)
         f = open(fn1, 'wb')
         f.write(data[i:i+ chunkSize])
         f.close()
         #self.encrypt(fn1, encryptedChunk, chunkKey, entropy)
         
   def join_(self, division_name,noOfChunks,chunkSize):
      '''Join the divided file'''
      dataList = []
      for i in range(0,noOfChunks,1):
         chunkNum=i * chunkSize
         chunkName = division_name+'%s'%chunkNum
         f = open(chunkName, 'rb')
         dataList.append(f.read())
         #f.close()
      f = open(division_name, 'wb')   
      for data in dataList:
         f.write(data)
         #f.close()

   def tarinfo(self, tarinfo):
      tarinfo.uid = tarinfo.gid = 0
      tarinfo.uname = tarinfo.gname = "root"
      return tarinfo



   def MadEncrypt(self, doc, encryptedDoc, key_out, entropy, RubbishOutput, n, chunkSize, division_name, chunks, tarIN, tarName, tarkey):
      '''[doc (+) key_out(entropy)] + RubbishOutput(n) = encryptedDoc
         encryptedDoc / chunkSize = division_name(chunkSize)
         tar[division_name(chunkSize)] (+) tarkey = tarName

         I guess that explains it....:)
         '''
      self.encrypt(doc, encryptedDoc, key_out, entropy)
      self.rubbish(encryptedDoc, RubbishOutput, n)
      self.divide(encryptedDoc, chunkSize, division_name, entropy)

      tar = tarfile.open(tarIN, 'w:tar')
      tar.add(chunks, filter=self.tarinfo)
      tar.close()

      self.encrypt(tarIN, tarName, tarkey, entropy)

   def MadDecrypt(self, division_name, noOfChunks, chunkSize, key, decrypted_file, tarName, tarkey, tarOut, tarOutFolder):
      '''Decrypt a MadEncryption'''
      self.decrypt(tarName, tarkey, tarOut)
      tar = tarfile.open(tarOut)
      tar.extractall(tarOutFolder)
      tar.close()
      ##Create Folder for extracting encrypted docs
      self.join_(division_name, noOfChunks, chunkSize)
      self.decrypt(division_name, key, decrypted_file)








